// Copyright 2020 Energinet DataHub A/S
//
// Licensed under the Apache License, Version 2.0 (the "License2");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Energinet.DataHub.ProcessManager.Abstractions.Core.ValueObjects;
using Energinet.DataHub.ProcessManager.Core.Domain.FileStorage;
using Energinet.DataHub.ProcessManager.Core.Domain.OrchestrationInstance;
using NodaTime;
using NodaTime.Text;

namespace Energinet.DataHub.ProcessManager.Core.Domain.SendMeasurements;

public class SendMeasurementsInstance // TODO: Name? SendMeasurementsInstance instead?
{
    public SendMeasurementsInstance(
        Instant createdAt,
        Actor createdBy,
        TransactionId transactionId,
        MeteringPointId? meteringPointId)
    {
        Id = SendMeasurementsInstanceId.CreateNew();

        CreatedAt = createdAt;
        CreatedByActorNumber = createdBy.Number;
        CreatedByActorRole = createdBy.Role;

        TransactionId = transactionId;
        MeteringPointId = meteringPointId;
    }

    /// <summary>
    /// Used by Entity Framework
    /// </summary>
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    // ReSharper disable once UnusedMember.Local -- Used by Entity Framework
    private SendMeasurementsInstance()
    {
    }
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

    public SendMeasurementsInstanceId Id { get; }

    public Instant CreatedAt { get; }

    public ActorNumber CreatedByActorNumber { get; }

    public ActorRole CreatedByActorRole { get; }

    public TransactionId TransactionId { get; }

    public MeteringPointId? MeteringPointId { get; }

    public Instant? SentToMeasurementsAt { get; private set; }

    public Instant? TerminatedAt { get; private set; }

    public Instant? FailedAt { get; private set; }

    public SendMeasurementsInstanceLifecycle Lifecycle => new SendMeasurementsInstanceLifecycle(
        terminatedAt: TerminatedAt,
        failedAt: FailedAt);

    public FileStorageReference FileStorageReference => FileStorageReference.ForSendMeasurementsInstanceInput(
        CreatedAt,
        CreatedByActorNumber,
        TransactionId);

    /// <summary>
    /// RowVersion is generated by the database and used for optimistic concurrency. Must be retrieved when loading
    /// the entity from the database, since Entity Framework uses it to throw an exception if the entity has been updated.
    /// </summary>
    /// <remarks>
    /// See https://learn.microsoft.com/en-us/ef/core/saving/concurrency?tabs=fluent-api
    /// </remarks>
    internal byte[]? RowVersion { get; }

    public void MarkAsSentToMeasurements(Instant sentToMeasurementsAt)
    {
        if (SentToMeasurementsAt is not null)
            throw new InvalidOperationException($"Cannot mark instance as sent to a measurements (Id={Id.Value}, SentToMeasurementsAt={InstantPattern.General.Format(SentToMeasurementsAt.Value)}).");

        SentToMeasurementsAt = sentToMeasurementsAt;
    }

    public record SendMeasurementsInstanceLifecycle
    {
        public SendMeasurementsInstanceLifecycle(
            Instant? terminatedAt,
            Instant? failedAt)
        {
            if (failedAt is not null)
            {
                State = OrchestrationInstanceLifecycleState.Terminated;
                TerminationState = OrchestrationInstanceTerminationState.Failed;
            }
            else if (terminatedAt is not null)
            {
                State = OrchestrationInstanceLifecycleState.Terminated;
                TerminationState = OrchestrationInstanceTerminationState.Succeeded;
            }
            else
            {
                State = OrchestrationInstanceLifecycleState.Running;
            }
        }

        public OrchestrationInstanceLifecycleState State { get; private set; }

        public OrchestrationInstanceTerminationState? TerminationState { get; private set; }
    }
}
